\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программы, а также проведен сравнительный анализ алгоритмов при различных ситуациях на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование представлены далее:

\begin{itemize}
    \item операционная система: Ubuntu 22.04.3 \cite{ubuntu} Linux \cite{linux} x86\_64;
    \item память: 16 Гб;
    \item процессор: Intel® Core™ i5-1135G7 @ 2.40Гц.
\end{itemize}

При тестировании ноутбук не был включен в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, а также системой тестирования.

\section{Демонстрация работы программы}

На рисунках \ref{img:example1}, \ref{img:example2} представлен результат работы программы.

\imgHeight{64mm}{example1}{Пример работы программы}

\imgHeight{100mm}{example2}{Пример работы программы}


\section{Время выполнения алгоритмов}

Как было сказано выше, используется функция замера процессорного времени process\_time() из библиотеки time на Python. Функция возвращает пользовательское процессорное время типа float.

Функция используется дважды: перед началом выполнения алгоритма и после завершения, затем из конечного времени вычитается начальное, чтобы получить результат.

Замеры проводились по 100 раз на различных входных данных для длины слова от 1 до 10 в случае рекурсивного алгоритма Дамерау-Левенштейна и от 1 до 100 для остальных алгоритмов.

Результаты замеров приведены в таблице \ref{tbl:time_mes} (время в мс). Время для рекурсивной реализации алгоритма Дамерау-Левентшейна измерялось только для длины строки не более 10, так как он работает относительно сильно дольше остальных.

\begin{table}[h]
    \begin{center}
        \begin{threeparttable}
        \captionsetup{justification=raggedright,singlelinecheck=off}
        \caption{Результаты замеров времени}
        \label{tbl:time_mes}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            Длина & Л.(матр.) & Д.-Л.(матр.)& Д.-Л.(рек.) & Д.-Л.(рек. с кешэм)  \\
            \hline
            1 & 0.0068 & 0.0057 & 0.0012 & 0.0064 \\ 
            \hline
            2 & 0.0092 & 0.0090 & 0.0048 & 0.0148 \\ 
            \hline
            3 & 0.0099 & 0.0120 & 0.0237 & 0.0227 \\ 
            \hline
            4 & 0.0127 & 0.0126 & 0.1229 & 0.0270 \\ 
            \hline
            5 & 0.0133 & 0.0147 & 0.6894 & 0.0321 \\ 
            \hline
            6 & 0.0152 & 0.0182 & 3.9311 & 0.0439 \\ 
            \hline
            7 & 0.0181 & 0.0201 & 22.0361 & 0.0579 \\ 
            \hline
            8 & 0.0204 & 0.0257 & 126.6794 & 0.0754 \\ 
            \hline
            9 & 0.0256 & 0.0317 & 793.4876 & 0.0957 \\ 
            \hline
            10 & 0.0308 & 0.0393 & 4651.9602 & 0.1208 \\ 
            \hline
            20 & 0.1632 & 0.1921 & - & 0.7842 \\ 
            \hline
            30 & 0.4343 & 0.4678 & - & 1.6324 \\ 
            \hline
            40 & 0.7198 & 0.7923 & - & 2.8983 \\ 
            \hline
            50 & 0.9457 & 1.1793 & - & 4.5392 \\ 
            \hline
            60 & 1.3146 & 1.7213 & - & 6.7496 \\ 
            \hline
            70 & 1.8647 & 2.3428 & - & 9.0544 \\ 
            \hline
            80 & 2.3966 & 3.0905 & - & 12.2664 \\ 
            \hline
            90 & 3.0661 & 3.8628 & - & 15.6859 \\ 
            \hline
            100 & 3.8084 & 4.7583 & - & 19.6995 \\ 
            \hline
		\end{tabular}
    \end{threeparttable}
\end{center}
\end{table}

Также на рисунках \ref{img:graph1}, \ref{img:graph2} приведены графические результаты замеров.

\imgHeight{100mm}{graph1}{Сравнение времени выполнения алгоритмов Левенштейна с использованием матрицы и Дамерау-Левенштейна с использованием матрицы, рекурсивный без кеша и с ним}
\imgHeight{100mm}{graph2}{Сравнение времени выполнения алгоритмов Левенштейна с использованием матрицы и Дамерау-Левенштейна с использованием матрицы и рекурсивный с использованием кеша}
\clearpage


\section{Использование памяти}

Алгоритмы поиска расстояний Левенштейна и Дамерау-Левенштейна, с точки зрения использования памяти, не отличаются друг от друга. Поэтому достаточно рассмотреть различия между рекурсивной и матричной реализациями этих алгоритмов.

При рекурсивной реализации алгоритма максимальная глубина стека вызовов равна сумме длин входящих строк. Таким образом, максимальный расход памяти можно вычислить с помощью формулы (\ref{for:99}).
\begin{equation}
	(sizeof(S_1) + sizeof(S_2)) \cdot (2 \cdot sizeof\mathrm{(string)} + 2 \cdot sizeof\mathrm{(int)} + sizeof\mathrm{(bool)}),
	\label{for:99}
\end{equation}
где $sizeof$ — оператор вычисления размера, $S_1$, $S_2$ — строки, $\mathrm{int}$ — целочисленный тип, $\mathrm{string}$ — строковый тип,  $\mathrm{bool}$ - логический тип.

Использование памяти при итеративной реализации теоретически вычисляется по формуле (\ref{for:100}).
\begin{equation}
	(sizeof(S_1) + 1) \cdot (sizeof(S_2) + 1) \cdot sizeof\mathrm{(int)} + 5\cdot sizeof\mathrm{(int)} + 2 \cdot sizeof\mathrm{(string)})
	\label{for:100}
\end{equation}

\section{Вывод}

В данном разделе было представлено сравнение количества затраченного времени и памяти алгоритмов поиска расстояний Левенштейна и Дамерау-Левенштейна. Наименее затратным по времени оказался итеративный алгоритм нахождения расстояния Левенштейна, а наиболее затратным --- рекурсивный алгоритм Дамерау-Левенштейна.

Исходя из замеров по памяти, итеративные алгоритмы проигрывают рекурсивным, потому что максимальный размер памяти в них растет, как произведение длин строк, а в рекурсивных --- как сумма длин строк.

Так как во время печати очень часто возникают ошибки связанные с транспозицией букв, алгоритм поиска расстояния Дамерау-Левенштейна является наиболее предпочтительным, не смотря на то, что он проигрывает по времени и памяти алгоритму Левенштейна.

Также при проведении эксперимента было выявлено, что на длине строк в 4 символа рекурсивная реализация алгоритма Дамерау-Левенштейна уже в 10 раз медленнее матричной реализации. При увеличении длины строк в геометрической прогрессии растет и время работы рекурсивной реализации. Следовательно, стоит использовать матричную реализацию для строк длиной более 4 символов.

