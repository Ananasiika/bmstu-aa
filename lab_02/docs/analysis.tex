\chapter{Аналитическая часть}
В этом разделе будут представлены алгоритмы умножения матриц: классический, Винограда и Штрассена.


\section{Матрица}

\textbf{Матрица} --- математический объект, который представляет собой двумерный массив, в котором элементы располагаются по строкам и столбцам \cite{matrix}.

Пусть $A$ --- матрица, тогда $A_{i,j}$ --- элемент этой матрицы, который находится на \textit{i-ой} строке и \textit{j-ом} столбце.

Можно выделить следующие операции над матрицами:
\begin{enumerate}[label=\arabic*)]
    \item матрицы одинакового размера можно складывать и вычитать;
    \item если в 2 матрицах количество столбцов одной матрицы равно количеству строк другой матрицы --- их можно перемножить, причем количество строк результирующей матрицы будет, как у первой, а столбцов --- как у второй. 
\end{enumerate}

\textit{Замечание:} операция умножения матриц не коммутативна --- если \textit{A} и \textit{B} --- квадратные матрицы, а \textit{C} --- результат их перемножения, то произведение \textit{AB} и \textit{BA} дадут разный результат \textit{C}.


\section{Стандартный алгоритм}
Пусть даны две матрицы

\begin{equation}
	A_{lm} = \begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1m}\\
		a_{21} & a_{22} & \ldots & a_{2m}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{l1} & a_{l2} & \ldots & a_{lm}
	\end{pmatrix},
	B_{mn} = \begin{pmatrix}
		b_{11} & b_{12} & \ldots & b_{1n}\\
		b_{21} & b_{22} & \ldots & b_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		b_{m1} & b_{m2} & \ldots & b_{mn}
	\end{pmatrix},
\end{equation}
тогда матрица $C$
\begin{equation}
	C_{ln} = \begin{pmatrix}
		c_{11} & c_{12} & \ldots & c_{1n}\\
		c_{21} & c_{22} & \ldots & c_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		c_{l1} & c_{l2} & \ldots & c_{ln}
	\end{pmatrix},
\end{equation}
где
\begin{equation}
	\label{eq:M}
	c_{ij} =
	\sum_{r=1}^{m} a_{ir}b_{rj} \quad (i=\overline{1,l}; j=\overline{1,n})
\end{equation}
будет называться произведением матриц $A$ и $B$.
Стандартный алгоритм реализует данную формулу.


\section{Алгоритм Винограда}

\textbf{Алгоритм Винограда} — алгоритм умножения квадратных матриц, основанный на идее уменьшения количества умножений, заменяя их сложением и вычитанием \cite{vinograd-matrix}.

Рассмотрим два вектора $V = (v_1, v_2, v_3, v_4)$ и $W = (w_1, w_2, w_3, w_4)$.
Их скалярное произведение равно: $V \cdot W = v_1w_1 + v_2w_2 + v_3w_3 + v_4w_4$, что эквивалентно (\ref{for:new}):
\begin{equation}
	\label{for:new}
	V \cdot W = (v_1 + w_2)(v_2 + w_1) + (v_3 + w_4)(v_4 + w_3) - v_1v_2 - v_3v_4 - w_1w_2 - w_3w_4.
\end{equation}


Пусть матрицы $A, B, C$ ранее определенных размеров. Упомянутое скалярное произведение, по замыслу Винограда, можно произвести иначе в формуле (\ref{equ:example_scal_mul_matrix}):
\begin{equation} 
	\label{equ:example_scal_mul_matrix}
	C_{ij} = \sum_{k=1}^{q/2}(a_{i,2k-1} + b_{2k,j})(a_{i,2k} + b_{2k-1,j}) - \sum_{k=1}^{q/2} a_{i,2k-1}a_{i,2k} - \sum_{k=1}^{q/2} b_{2k-1,j}b_{2k,j}
\end{equation}

Казалось бы, это только увеличит количество арифметических операций по сравнению с классическим методом, однако Виноград предложил находить второе и третье слагаемые в формуле (\ref{equ:example_scal_mul_matrix}) предварительном этапе вычислений, заранее для каждой строки матрицы $A$ и столбца $B$ соответственно. Так, вычислив единожды для строки $i$ матрицы $A$ значение выражения $\sum_{k=1}^{q/2}a_{i,2k-1}a_{i,2k}$ его можно далее использовать m раз при нахождении элементов $i$-ой строчки матрицы $C$. Аналогично, вычислив единожды для
столбца $j$ матрицы $B$ значение выражения $\sum_{k=1}^{q/2} b_{2k-1,j}b_{2k,j}$ его можно
далее использовать n раз при нахождении элементов $j$-ого столбца матрицы $C$ \cite{book_vinograd}.

За счёт предварительной обработки данных можно получить прирост производительности: несмотря на то, что полученное выражение требует большего количества операций, чем стандартное умножение матриц, выражение в правой части равенства можно вычислить заранее и запомнить для каждой строки первой матрицы и каждого столбца второй матрицы. Это позволит выполнить лишь два умножения и пять сложений, при учёте, что потом будет сложено только с двумя предварительно посчитанными суммами соседних элементов текущих строк и столбцов. Операция сложения выполняется
быстрее, поэтому на практике алгоритм должен работать быстрее обычного алгоритма перемножения матриц.

Стоит упомянуть, что при нечётном значении размера матрицы нужно дополнительно добавить произведения крайних элементов соответствующих строк и столбцов.

\section{Оптимизированный алгоритм Винограда}

При программной реализации рассмотренного выше алгоритма Винограда можно сделать следующие оптимизации:
\begin{enumerate}[label=\arabic*)]
	\item предвычислять некоторые слагаемые для алгоритма;
	\item операцию умножения на 2 программно эффективнее реализовывать как побитовый сдвиг влево на 1;
	\item операции сложения и вычитания с присваиванием следует реализовывать при помощи соответствующего оператора $+=$ или $-=$ (при наличии данных операторов в выбранном языке программирования).
\end{enumerate}

\section{Алгоритм Штрассена}
Алгоритм Штрассена является эффективным методом умножения матриц, который основан на принципе "разделяй и властвуй". Он позволяет уменьшить время выполнения умножения матриц за счет рекурсивного разделения матриц на более маленькие подматрицы, но относительно других алгоритмов он эффективен только при достаточно больших размерах матриц (более 100), так как на вызов рекурсии требуется много времени \cite{book_shtrassen}.

Алгоритм Штрассена следует следующим шагам:
\begin{enumerate}[label=\arabic*)]
	\item Разделить исходные матрицы $A$ и $B$ на равные подматрицы размером $n/2$.
	\item Вычислить семь промежуточных матриц путем рекурсивного умножения.
	\item Сложить и вычесть эти промежуточные матрицы, чтобы получить результат умножения.
\end{enumerate}

Алгоритм Штрассена имеет следующую рекурсивную формулу (\ref{equ:shtrassen}).


\begin{equation}
	\label{equ:shtrassen}
	C = \begin{pmatrix}
		C_{11} & C_{12} \\
		C_{21} & C_{22} \\
	\end{pmatrix} = \begin{pmatrix}
		A_{11} & A_{12} \\
		A_{21} & A_{22} \\
	\end{pmatrix}
	\begin{pmatrix}
		B_{11} & B_{12} \\
		B_{21} & B_{22} \\
	\end{pmatrix}
\end{equation}

$C_{11} = M_1 + M_4 - M_5 + M_7$, $C_{12} = M_3 + M_5$, 

$C_{21} = M_2 + M_4$, $C_{22} = M_1 - M_2 + M_3 + M_6$,

где

$M_1 = (A_{11} + A_{22})(B_{11} + B_{22}),$
$M_2 = (A_{21} + A_{22})B_{11},$
$M_3 = A_{11}(B_{12} - B_{22}),$

$M_4 = A_{22}(B_{21} - B_{11}),$
$M_5 = (A_{11} + A_{12})B_{22},$
$M_6 = (A_{21} - A_{11})(B_{11} + B_{12}),$

$M_7 = (A_{12} - A_{22})(B_{21} + B_{22}).$

Алгоритм Штрассена имеет лучшую асимптотическую сложность, чем стандартный алгоритм умножения матриц. Однако он имеет более высокую константу, поэтому может быть эффективным только для очень больших матриц. Реализация алгоритма Штрассена требует дополнительной памяти для хранения промежуточных матриц, поэтому также чувствителен к ограниченным ресурсам памяти компьютера.


\section{Вывод}
В данном разделе были рассмотрены алгоритмы умножения матриц - стандартного, Винограда, Винограда с оптимизацией и Штрассена.
Алгоритм стандартного умножения матриц является простым и прямолинейным, но имеет временную сложность $O(n^3)$, где n - размерность матрицы.

Алгоритм умножения матриц Винограда вводит дополнительные расчеты для оптимизации операций умножения. Это позволяет сократить количество операций умножения и тем самым улучшить производительность. Однако, он оказывается выигрышным только для больших матриц.

Алгоритм Штрассена базируется на использовании деления матрицы на подматрицы и рекурсивном умножении этих подматриц. Это позволяет значительно сократить количество операций умножения, но требует дополнительных операций сложения матриц. В определенных случаях (зависит от размера матрицы) алгоритм Штрассена оказывается эффективнее остальных алгоритмов, но на маленьких матрицах может быть менее производительным.

